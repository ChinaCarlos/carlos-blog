---
title: JavaScript 面试基础知识(上篇)
tags: front interview
theme: solarized-dark
---

# JavaScript 面试基础知识(上篇)

在 JavaScript 中，数据类型分为 **原始类型** 和 **引用类型**。

### 1. 原始类型 (Primitive Types)

| 类型        | 描述                                   | 示例                    |
| ----------- | -------------------------------------- | ----------------------- |
| `undefined` | 表示未定义的值，变量未赋值时的默认值。 | `let x;`                |
| `null`      | 表示空值，通常用于表示空对象引用。     | `let x = null;`         |
| `boolean`   | 布尔类型，表示 `true` 或 `false` 值。  | `let x = true;`         |
| `number`    | 数字类型，表示整数或浮点数。           | `let x = 42;`           |
| `bigint`    | 表示任意精度的大整数。                 | `let x = 123n;`         |
| `string`    | 字符串类型，表示文本数据。             | `let x = "hello";`      |
| `symbol`    | 表示唯一的标识符，通常用于对象属性键。 | `let x = Symbol("id");` |

#### 2. 引用类型 (Reference Types)

| 类型       | 描述                                     | 示例                           |
| ---------- | ---------------------------------------- | ------------------------------ |
| `object`   | 对象类型，可以存储键值对和复杂数据结构。 | `let obj = { name: "Alice" };` |
| `array`    | 数组对象，用于存储有序集合。             | `let arr = [1, 2, 3];`         |
| `function` | 函数对象，表示可调用的代码块。           | `function greet() {}`          |
| `date`     | 日期对象，表示日期和时间。               | `let date = new Date();`       |

#### 3. 特殊数据类型

- **`NaN`**: 表示“不是一个数字”的特殊值，通常出现在无效的数学运算中（如 `0 / 0`）。
- **`Infinity` 和 `-Infinity`**: 表示正无穷大和负无穷大，出现在数值运算超出范围时（如 `1 / 0`）。

#### JavaScript 数据类型总结

JavaScript 数据类型大致可以分为两大类：

- **原始类型**：`undefined`、`null`、`boolean`、`number`、`bigint`、`string`、`symbol`
- **引用类型**：`object`

### 2. 什么是闭包，以及闭包有什么使用场景？

::: warning 各有理解
首先闭包正确的定义是：假如一个函数能访问外部的变量，那么就形成了一个闭包，而不是一定要返回一个函数。
:::
**闭包**是指在 JavaScript 中，一个函数能够访问其定义时所在作用域的变量，即使该函数在其作用域外被调用。闭包的主要使用场景包括：

- **数据封装**：利用闭包，可以创建私有变量，使得外部无法直接修改。
- **函数工厂**：在函数内部生成带有特定行为的函数。
- **状态保持**：可以保持函数内的状态，比如在多次调用时保留变量值。
- **回调与异步操作**：在异步操作中使用闭包可以访问外部作用域中的变量，适用于事件处理、计时等场景。

---

### 3. 什么是执行上下文

**执行上下文（Execution Context）** 是 JavaScript 代码执行的环境，每当 JavaScript 代码运行时都会创建一个执行上下文。执行上下文包含以下类型：

- **全局执行上下文**：在代码最外层的全局环境，只有一个。
- **函数执行上下文**：每次函数调用时都会创建一个新的上下文。
- **Eval 执行上下文**：在 `eval()` 执行时创建（不推荐使用）。

每个执行上下文包含 **变量对象**（存储变量和函数）、**作用域链**、和 **this** 的引用。

---

### 4. 什么是作用域

**作用域**是指程序中定义变量和函数的可访问范围。JavaScript 中的作用域分为：

- **全局作用域**：全局范围内的所有变量和函数，整个脚本可访问。
- **函数作用域**：每个函数创建独立的作用域，局部变量只能在该函数内访问。
- **块级作用域**：通过 `let` 和 `const` 关键字创建的块作用域，仅在 `{}` 中有效。

作用域控制了变量的可见性和生命周期，有助于避免变量命名冲突。

---

### 5. 什么是变量提升

**变量提升（Hoisting）** 是指在 JavaScript 中，变量声明和函数声明会在代码执行前被提升到其作用域的顶部。这意味着可以在声明前使用变量或函数，但未初始化的 `var` 变量会是 `undefined`。

```javascript
console.log(x); // undefined
var x = 10;
```

使用 let 和 const 声明的变量不会被提升到顶部，仍然处于 暂时性死区，未声明前无法使用。

### 6. 隐式类型转换有哪些？

JavaScript 中的 **隐式类型转换** 发生在不同数据类型之间进行运算时，主要包括以下几种情况：

- **字符串拼接**：当数字与字符串相加时，会将数字转换为字符串。
- **布尔值转换**：在条件判断中，非布尔类型会被转换为布尔值（例如，`0`、`null`、`undefined`、`NaN`、`""` 会被转换为 `false`）。
- **数值转换**：在涉及数学运算（如减法、乘法）时，会将字符串或布尔值转换为数字。
- **对象转换**：在对象与原始值比较时，对象会先转换为原始类型（通常是调用 `valueOf` 或 `toString` 方法）。

```javascript
console.log(1 + "2"); // "12"
console.log("5" - 3); // 2
console.log(!!""); // false
```

### 7. 什么是原型链/原型

**原型链** 是 JavaScript 实现继承的机制。每个对象都有一个私有属性 `[[Prototype]]`，通常通过 `__proto__` 访问，指向其构造函数的原型对象。JavaScript 在访问一个对象的属性时，若该对象本身没有该属性，则会沿原型链向上查找，直到找到该属性或到达 `null`（即原型链的顶端）。

```javascript
function Person() {}
const person = new Person();
console.log(person.__proto__ === Person.prototype); // true
```

### 8. 如何判断一个变量的类型

判断变量类型的几种方法：

- **`typeof`**：适合判断基本数据类型，但对于 `null` 和对象的区分不明确。
- **`instanceof`**：用于判断对象是否为某个构造函数的实例。
- **`Object.prototype.toString.call()`**：更精确的类型检测方法，返回如 `[object Array]` 这样的类型字符串。

```javascript
console.log(typeof 123); // "number"
console.log([] instanceof Array); // true
console.log(Object.prototype.toString.call([])); // "[object Array]"
// 还有其他方式。。。。
```

### 9. 什么是深拷贝？什么又是浅拷贝？

**浅拷贝** 和 **深拷贝** 都是对象拷贝的方式，但两者在拷贝的方式上有所不同：

#### 1. 浅拷贝

**浅拷贝** 是对对象的第一层属性进行拷贝。如果对象的属性是引用类型（如数组或对象），则拷贝的仍然是引用地址，而非实际的值。修改拷贝后的对象的引用类型属性，原对象的该属性也会受到影响。

常用的浅拷贝方法：

- 使用 `Object.assign()`
- 使用扩展运算符（`...`）

```javascript
const obj = { a: 1, b: { c: 2 } };
const shallowCopy = Object.assign({}, obj);
shallowCopy.b.c = 3;

console.log(obj.b.c); // 3, 原对象也受影响
console.log(shallowCopy.b.c); // 3
```

#### 2. 深拷贝

**深拷贝** 是指创建一个对象的完全独立副本，其中对象及其嵌套的所有对象和数组都会被递归地拷贝。深拷贝确保新对象和原对象在内存中是完全独立的，修改一个对象的内容不会影响另一个对象。

#### 深拷贝的特点：

- 会创建一个新对象，新对象与原对象没有任何引用关系。
- 所有嵌套的对象或数组会被递归复制，确保每一层都是独立的。
- 修改深拷贝后的对象不会影响原对象，反之亦然。

#### 常见的深拷贝方法：

1. **使用 `JSON.parse(JSON.stringify())`**
   这是最常用的简便方法，适用于没有函数、`undefined` 和 `Symbol` 的对象。它通过将对象序列化为 JSON 字符串，再将其反序列化为新对象，来实现深拷贝。在工作当中，通常使用`lodash-es`这种库提供的公共方法。

   ```javascript
   const obj = { a: 1, b: { c: 2 } };
   const deepCopy = JSON.parse(JSON.stringify(obj));
   deepCopy.b.c = 3;

   console.log(obj.b.c); // 2, 原对象不受影响
   console.log(deepCopy.b.c); // 3
   ```

### 10. 如何实现一个继承

### 11. JS this 的指向

### 12. bind, call, apply 区别是什么？都分别是干什么用的
