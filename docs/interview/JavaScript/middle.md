---
title: JavaScript 面试基础知识(中篇)
tags: front interview
theme: solarized-dark
---

# JavaScript 面试基础知识(中篇)

## 1. 什么是进程？什么又是线程

| 特性     | 进程                             | 线程                             |
| -------- | -------------------------------- | -------------------------------- |
| 定义     | 程序的独立运行实例               | 进程内的最小执行单位             |
| 资源分配 | 拥有独立的资源和内存空间         | 共享所在进程的资源和内存         |
| 开销     | 创建、销毁、切换开销较大         | 开销较小                         |
| 执行效率 | 并行执行效率相对低               | 在多核 CPU 中更易实现并发        |
| 稳定性   | 进程崩溃不影响其他进程           | 线程崩溃会影响所在进程           |
| 通信方式 | 需要进程间通信（IPC）            | 可以直接访问进程中的共享数据     |
| 使用场景 | 高隔离需求的任务，独立运行的程序 | 多任务并发，如并行处理和任务分配 |

## 2. 并发与并行的区别

**并发**和**并行**都是处理多个任务的概念，但它们有一些关键的不同：

### 并发（Concurrency）

**并发**是指在同一时间段内**处理多个任务**。在并发的情况下，多个任务可以交替执行，但不一定同时执行。并发主要依靠时间片轮转等机制让任务看起来像是“同时”进行，但在某个时刻只有一个任务在执行。

- **实现方式**：通过任务切换，在不同任务之间快速切换，使得用户感觉到多个任务同时进行。
- **应用场景**：适用于单核或多核系统，尤其是 I/O 密集型任务，比如网络请求、文件读写等。
- **例子**：假设一个单核处理器在短时间内快速交替执行任务 A 和任务 B，看起来像是它们在同时执行，但实际上是快速切换的结果。

### 并行（Parallelism）

**并行**是指在**相同时间点上执行多个任务**。并行需要多核 CPU 或多台处理器同时工作，真正地做到同时运行多个任务。

- **实现方式**：在多核 CPU 或多台处理器上让不同任务在不同核上真正地同时执行。
- **应用场景**：多核系统的计算密集型任务，比如图像处理、科学计算等。
- **例子**：在四核 CPU 上同时运行四个独立的计算任务，每个任务在不同的核心上运行，真正地在同一时刻完成多个任务。

### 并发与并行的区别

| 特性     | 并发                      | 并行                               |
| -------- | ------------------------- | ---------------------------------- |
| 定义     | 同一时间段内处理多个任务  | 同一时间点上执行多个任务           |
| 执行方式 | 任务交替执行，快速切换    | 任务在不同的处理器或核心上同时执行 |
| 系统需求 | 适用于单核或多核系统      | 需要多核系统或多处理器             |
| 适用场景 | I/O 密集型任务            | 计算密集型任务                     |
| 示例     | 单核 CPU 交替执行多个任务 | 多核 CPU 上同时执行多个任务        |

### 总结

- **并发**：任务交替执行，在同一时间段内处理多个任务。
- **并行**：任务真正同时执行，在同一时刻完成多个任务。

并发可以在单核系统中实现，而并行需要多核或多处理器系统来实现。

## 3.什么是重绘（Repaint）和回流（Reflow）

**重绘**和**回流**是浏览器渲染页面的两个关键过程，主要影响页面性能和用户体验。理解它们的区别可以帮助优化页面渲染，提高性能。

### 1. 什么是重绘（Repaint）

**重绘**是指当元素的**外观**发生变化，但**不影响布局**时，浏览器重新渲染元素的过程。例如更改元素的颜色、背景图片或可见性等属性。

- **触发条件**：只更改元素的外观（如颜色、背景等），不涉及尺寸、位置或结构变化。
- **性能影响**：重绘的开销相对较小，因为浏览器只需更新元素的外观，而不需要重新计算布局。
- **示例**：
  ```javascript
  element.style.color = "red"; // 更改颜色，触发重绘
  element.style.visibility = "hidden"; // 更改可见性，触发重绘
  ```

### 2. 什么是回流（Reflow）

**回流**（也称重排）是指当页面中元素的**尺寸、位置、布局**或结构发生变化时，浏览器需要重新计算元素的布局并重新渲染的过程。回流是一个更耗性能的过程，因为浏览器需要重新计算所有相关元素的位置和布局。

- **触发条件**：任何改变元素布局或结构的操作（如添加、删除元素，改变元素尺寸、边距、边框、位置等）都会触发回流。
- **性能影响**：回流的性能开销较大，因为不仅需要重新计算该元素，还可能会影响其他元素，甚至导致整个页面的重新布局。
- **示例**：
  ```javascript
  element.style.width = "200px"; // 更改宽度，触发回流
  element.style.marginTop = "20px"; // 更改外边距，触发回流
  ```

### 如何减少重绘和回流

为了提升页面性能，减少不必要的重绘和回流，可以采取以下优化策略：

1. **合并操作**：合并多次对元素样式的更改，尽量减少单独更改样式的次数。例如，可以使用 `class` 一次性更改多个属性。
2. **减少 DOM 操作**：频繁的 DOM 操作会导致回流，建议减少直接操作 DOM。可以使用 `DocumentFragment` 或虚拟 DOM 来批量更新，降低操作频率。
3. **避免频繁读取样式**：读取样式会触发浏览器重新计算布局，建议将读取和修改样式的操作分开，避免频繁读取。
4. **使用 `transform` 和 `opacity` 属性**：这些属性只会触发重绘，不会导致回流，适合做动画效果。
5. **CSS 动画优化**：将动画应用于 `transform` 或 `opacity` 属性，避免改变尺寸或位置等会导致回流的属性。
6. **减少复杂选择器**：复杂的 CSS 选择器会增加计算时间，使用更简单的选择器可以提升性能。
7. **批量操作样式**：通过 `element.style.cssText` 一次性应用多项样式，而不是多次单独应用。
8. **使用 `will-change`**：对于需要动画或频繁变化的属性，可以通过 `will-change` 属性提前通知浏览器进行优化处理。

---

### 重绘和回流的对比

| 特性     | 重绘（Repaint）                        | 回流（Reflow）                                           |
| -------- | -------------------------------------- | -------------------------------------------------------- |
| 定义     | 仅更新元素的外观（如颜色），不影响布局 | 更新元素的布局、尺寸或结构，重新计算布局                 |
| 触发条件 | 改变颜色、背景、可见性等               | 改变尺寸、位置、结构等                                   |
| 性能影响 | 开销较小，只需更新外观                 | 开销较大，重新计算布局，可能影响整个页面                 |
| 优化建议 | 尽量合并外观更新，减少样式变动频率     | 合并布局更新、减少 DOM 操作、使用 transform/opacity 属性 |
| 示例     | `color`、`background`                  | `width`、`height`、`display`、`margin`                   |

## 4. 浏览器存储都有哪些？

| 存储方式                       | 用途                                                 | 容量限制                         | 有效期                             | 访问方式                                       | 特点                                         |
| ------------------------------ | ---------------------------------------------------- | -------------------------------- | ---------------------------------- | ---------------------------------------------- | -------------------------------------------- |
| **Cookie**                     | 存储少量文本数据，如用户登录状态等                   | 每个 Cookie 约 4 KB              | 可设置过期时间，默认会话结束时失效 | 通过 JavaScript 访问，HTTP 请求/响应中也可使用 | 随每个 HTTP 请求发送，安全性较低，容易被篡改 |
| **LocalStorage**               | 存储长期数据，如用户设置、配置信息等                 | 5-10 MB                          | 永久存储，除非手动清除             | 通过 JavaScript 访问                           | 不随请求发送数据，支持跨页面存取数据         |
| **SessionStorage**             | 存储会话期间的数据，如一次会话中的临时数据           | 5-10 MB                          | 浏览器会话结束时失效               | 通过 JavaScript 访问                           | 仅在当前窗口或标签页有效，窗口关闭时数据清除 |
| **IndexedDB**                  | 存储结构化数据，适用于大数据存储和查询               | 没有严格限制，取决于浏览器和设备 | 永久存储，除非手动删除             | 通过 JavaScript API 访问                       | 支持事务操作，存储结构化数据，适合大数据存储 |
| **Web SQL Database**（已弃用） | 存储结构化数据，基于 SQL 的数据库存储                | 5 MB 或更大                      | 永久存储，除非手动删除             | 通过 SQL 查询语句访问                          | 已弃用，未来不再支持，建议使用 IndexedDB     |
| **Cache API**                  | 存储资源（文件、图像、JS、CSS 等），主要用于离线缓存 | 容量通常较大                     | 可设置过期时间，过期后删除         | 通过 JavaScript API 访问                       | 适用于 PWA 离线支持，自动管理缓存空间        |

:::warning 明确一点，localStorage 是同步的

是的，硬盘确实是一个 IO 设备，而大部分与硬盘相关的操作系统级 IO 操作确实是异步进行的，以避免阻塞进程。不过，在 Web 浏览器环境中，localStorage  的 API 是设计为同步的，即使底层的硬盘读写操作有着 IO 的特性。
js 代码在访问  localStorage  时，浏览器提供的 API 接口通常会处于 js 执行线程上下文中直接调用。这意味着尽管硬盘是 IO 设备，当一个 js 执行流程访问  localStorage  时，它将同步地等待数据读取或写入完成，该过程中 js 执行线程会阻塞。
这种同步 API 设计意味着开发者在操作  localStorage  时不需要考虑回调函数或者 Promise 等异步处理模式，可以按照同步代码的方式来编写。不过，这也意味着如果涉及较多数据的读写操作时，可能对性能产生负面影响，特别是在主线程上，因为它会阻塞 UI 的更新和其他 js 的执行。

:::
